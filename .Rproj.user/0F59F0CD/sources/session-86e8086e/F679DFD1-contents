C:/Users/rmartin7/AppData/Local/Temp/image.png---
title: "Prepare ISTRAX tool"
output:
  #word_document: default
  html_document: default
date: "2025-09-04"
---



# Pulling data together

This pulls the data together we already have in our directory. Ultimately we want to merge this into a more dynamic data pipeline that ideally access the the PATSTAT API.

Note that all directory links are relative so you should be able to find all underlying datasets.



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE,warning=FALSE,fig.width = 9,fig.height = 10,dpi=2200)
source("../code/helpers.r")
library(dplyr)
library(readr)
library(readr)
library(dplyr)
library(wbstats)
library(arrow)
library(readr)
library(data.table)

```




I am pulling various datasets we have in the one drive to create three datastructures. Eventually we should establish a datapipeline that pulls that data from the PATSTAT API pipeline. All data should be in the shared drive and paths are relative so it should all work on your machines.

1. A dataset at the patent families (docdb level) with various family charactistics that we might want to show (patchar)

2. A dataset that maps patents to countrys (countrymap). Currently that's done via inventor locations. Note because the same inno can have innovators in multiple countries. The countrymap dataset includes - at least for now - also a national istrax variable. This is a variable which computes istrax such that only spillovers are considered that benefit the source country (i.e. for innovations linked to India say it is flows to other innovators in India). The long term goal - somebody; e.g. Denis, needs to re-run the algorithm for all countries - to have in the patchar dataset a to flow istrax column for every country and country group of interest. Once we have that national istrax is contained in this information.

3. A dataset that maps patent families to technology classes (techmap, again a family can be in multiple).
(Maybe in the medium run we want to replace that with a mapping of all patents to CPC subclasses combined with a separate - and much smaller - mapping from subclasses to specific technology tags)



4. We combine 1 & 2 to create patchar_countrymap, which is now more convenient for simply computing bar charts with national vs global spillovers istrax.


## Build mapping from patents to countries (countrymap)

```{r}


url="../../data/patent_data/patbis2021/data/fromWATSON/innos_ctry_indicators.dsv"


#url="../../data/patent_data/patbis2021/data/fromWATSON/innos_istraxfield_nationalkey_2009_2018.dsv"

countrymap <- read_tsv(url)
#countrymap=countrymap %>% distinct(docdb_family_id,ctry_code,istrax) %>% rename(istrax_nationalkey_2009_2018=istrax)
countrymap=countrymap %>% distinct(docdb_family_id,ctry_code,istrax_nationalkey_2009_2018)

```




## Build patchar


```{r}

url2="../../data/patent_data/patbis2021/data/fromWATSON/innos_istraxfield_global_2009_2018.dsv"
patchar=read_tsv(url2) %>%  select(docdb_family_id,istrax,alphapvyear_2009_2018,costpvyear_2009_2018,pv,ev) %>% rename(istrax_global=istrax) %>% 
   rename(cost=costpvyear_2009_2018,alpha=alphapvyear_2009_2018)

#library(fixest)
#reg=fepois(pv~ev,patchar) 
#reg %>% summary()






```




## Build patchar_countrymap

```{r}




patchar_countrymap = read_tsv(url) %>% select(docdb_family_id,ctry_code,
                            earliest_filing_date,earliest_filing_year,
                            docdb_family_size,
                            istrax_nationalkey_2009_2018) #%>% rename(istrax_nationalkey_2009_2018=istrax)

#...assuming this covers national we need global....

#test=
```
### check pv vs ev

```{r}
library(fixest)


test=patchar_countrymap %>% select(docdb_family_id,ctry_code) %>% 
   inner_join(patchar %>% select(docdb_family_id,ev,pv,cost,alpha)) %>% 
   mutate(lowid=pv<2*cost,
          thresdist=(pv-2*cost)/(2*cost),
          pvOcost=pv/cost,
          istraxid=(alpha+1)/cost*ev,
          evOcost=ev/cost) %>%
  select(-ctry_code) %>% distinct()
   
feols(ev ~ pv,test)
feols(ev ~  lowid, test)


feols(ev ~  thresdist, test)

feols(istraxid ~  thresdist, test)

feols(evOcost ~  pvOcost, test)



```
#### nice figures

```{r}
#test %>% ggplot(aes(x=pvOcost,y=evOcost)) + geom_point()




library(ggplot2)
library(dplyr)

# Create quintile bins and calculate averages
test_binned <- test %>%
  mutate(evOcost_quintile = ntile(evOcost, 10)) %>%
  group_by(evOcost_quintile) %>%
  summarise(
    mean_evOcost = mean(evOcost, na.rm = TRUE),
    mean_pvOcost = mean(pvOcost, na.rm = TRUE)
  )

# Create the plot
ggplot(test_binned, aes(x = mean_evOcost, y = mean_pvOcost)) +
  geom_point(size = 3) +
  geom_line() +
  labs(
    x = "evOcost (bin averages)",
    y = "Average pvOcost",
    title = "Average pvOcost by evOcost Quintiles"
  ) +
  theme_minimal()

```


#### now for thresdist


```{r}

library(ggplot2)
library(dplyr)

# Create quintile bins and calculate averages
test_binned <- test %>%
  mutate(thresdist_quintile = ntile(thresdist, 10)) %>%
  group_by(thresdist_quintile) %>%
  summarise(
    mean_thresdist = mean(thresdist, na.rm = TRUE),
    mean_ev = mean(ev, na.rm = TRUE)
  )

# Create the plot
ggplot(test_binned, aes(x = mean_thresdist*100, y = mean_ev)) +
  geom_point(size = 3) +
  geom_line() +
  labs(
    x = "% distance from cutoff threshold",
    y = "Average external value ($ millions)",
    title = "External vs private value"
  ) +
  theme_minimal()+
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") 


```



#### with horizontal  lines...


```{r}
library(ggplot2)
library(dplyr)

# Calculate average ev for both lowid groups
avg_ev_lowid1 <- test %>%
  filter(lowid == 1) %>%
  summarise(mean_ev = mean(ev, na.rm = TRUE)) %>%
  pull(mean_ev)

avg_ev_lowid0 <- test %>%
  filter(lowid == 0) %>%
  summarise(mean_ev = mean(ev, na.rm = TRUE)) %>%
  pull(mean_ev)

# Print the averages
cat("Average EV for lowid==1:", avg_ev_lowid1, "\n")
cat("Average EV for lowid==0:", avg_ev_lowid0, "\n")

# Create quintile bins and calculate averages
test_binned <- test %>%
  mutate(thresdist_quintile = ntile(thresdist, 10)) %>%
  group_by(thresdist_quintile) %>%
  summarise(
    mean_thresdist = mean(thresdist, na.rm = TRUE),
    mean_ev = mean(ev, na.rm = TRUE)
  )

# Create the plot
ggplot(test_binned, aes(x = mean_thresdist*100, y = mean_ev)) +
  geom_point(size = 3) +
  geom_line() +
  # Horizontal line for lowid==1 (from x=-100 to x=0)
  geom_segment(aes(x = -100, xend = 0, 
                   y = avg_ev_lowid1, yend = avg_ev_lowid1),
               color = "blue", linetype = "dashed", linewidth = 1) +
  # Horizontal line for lowid==0 (from x=0 to x=125)
  geom_segment(aes(x = 0, xend = 125, 
                   y = avg_ev_lowid0, yend = avg_ev_lowid0),
               color = "darkgreen", linetype = "dashed", linewidth = 1) +
  # Vertical line at cutoff
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  labs(
    x = "% distance from cutoff threshold",
    y = "Average external value ($ millions)",
    title = "External vs private value"
  ) +
  theme_minimal()



#########################################
library(ggplot2)
library(dplyr)

# Calculate average ev for both lowid groups
avg_ev_lowid1 <- test %>%
  filter(lowid == 1) %>%
  summarise(mean_ev = mean(ev, na.rm = TRUE)) %>%
  pull(mean_ev)

avg_ev_lowid0 <- test %>%
  filter(lowid == 0) %>%
  summarise(mean_ev = mean(ev, na.rm = TRUE)) %>%
  pull(mean_ev)

# Print the averages
cat("Average EV for lowid==1:", avg_ev_lowid1, "\n")
cat("Average EV for lowid==0:", avg_ev_lowid0, "\n")

# Create quintile bins and calculate averages
test_binned <- test %>%
  mutate(thresdist_quintile = ntile(thresdist, 10)) %>%
  group_by(thresdist_quintile) %>%
  summarise(
    mean_thresdist = mean(thresdist, na.rm = TRUE),
    mean_ev = mean(ev, na.rm = TRUE)
  )

# Create the plot
ggplot(test_binned, aes(x = mean_thresdist*100, y = mean_ev)) +
  geom_point(size = 3) +
  geom_line() +
  # Horizontal line for lowid==1 (from x=-100 to x=0)
  geom_segment(aes(x = -100, xend = 0, 
                   y = avg_ev_lowid1, yend = avg_ev_lowid1),
               color = "blue", linetype = "solid", linewidth = 1.5) +
  # Horizontal line for lowid==0 (from x=0 to x=125)
  geom_segment(aes(x = 0, xend = 125, 
                   y = avg_ev_lowid0, yend = avg_ev_lowid0),
               color = "darkgreen", linetype = "solid", linewidth = 1.5) +
  # Vertical line at cutoff
  geom_vline(xintercept = 0, color = "red", linetype = "dashed") +
  labs(
    x = "% distance from cutoff threshold",
    y = "Average external value ($ millions)",
    title = "External vs private value"
  ) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 16, face = "bold"),
    axis.title.y = element_text(size = 16, face = "bold"),
    plot.title = element_text(size = 18, face = "bold"),
    axis.text = element_text(size = 12)
  )

  
```
  

## Build More ISTRAX (we only have EV on file so still need to apply the istrax formula)


The formula is

$$\frac{1}{c}\times EV \times \left(\alpha-\alpha \times I\{PV>2 c\}+I\{PV<2 c\}\right) $$
$$=\frac{1}{c}\times EV \times \left(\alpha-\alpha \times I\{PV>2 c\}+\left(1-I\{PV>2 c\}\right)\right) $$
$$=\frac{1}{c}\times EV \times \left(1+\alpha-\left(\alpha+1\right) \times I\{PV>2 c\}\right) $$
$$=\frac{\alpha+1}{c}\times EV \times\left(1-  I\{PV>2 c\}\right) $$

## combine EVs

```{r}





library(rlang)




flist = c( "CN","emde","eu","euplusuk","g7","IN","emdenocn","emdenocnin","hic","AT","GB","DE","FR","US" )
#flist = c( "FR","US" )
for(ff in flist){
  ff=ff %>% toupper()
  newev=paste0("ev_",ff)
  jurl=paste0("../../data/patent_data/patbis2021/data/fromWATSON/innos_ev_",ff,"_2009_2018.dsv")
  newdf=read_tsv(jurl)
  ev_var_name <- names(newdf)[startsWith(names(newdf), "ev")]
  newdf=newdf %>% select(docdb_family_id,starts_with("ev")) %>% rename( !!newev:=!!sym(ev_var_name) )
  
  patchar=patchar %>% left_join( newdf )
}



patchar=patchar   %>% distinct() #%>% 
  #mutate(ev_EMDE=ev_EMDE,
         #ev_EMDEexCN=ev_EMDENOCN  ,
         #ev_EMDEexCNIN=ev_EMDENOCNIN,
         #ev_HIC=ev_HIC) 
  
  

#test=patchar  %>% filter(ev_EMDEexCNIN<0)
#test2=patchar %>% filter(ev_EMDEexCN<0)
#test3=patchar %>% filter(ev_test<0)
#test4=patchar %>% filter(ev_EMDE>ev)
```

Making Istraxes

```{r}


library(dplyr)
library(stringr)

# Optionally guard against division by zero:
# patchar <- patchar %>% mutate(cost = na_if(cost, 0))

patchar <- patchar %>%
  # Create istrax_* columns for every ev_* column
  mutate(
    across(
      .cols = starts_with("ev_"),
      .fns  = ~ ((alpha + 1) / cost) * .x * as.integer(pv <= 2 * cost),
      .names = "istrax_{.col}"      # temporary names: istrax_ev_XXX
    )
  ) %>%
  # Drop the extra "ev_" in the new names: istrax_ev_XXX -> istrax_XXX
  rename_with(~ str_replace(., "^istrax_ev_", "istrax_"), starts_with("istrax_ev_"))





```






## Build patchar_countrymap


```{r}







# Add global istrax to patchar_countrympa
patchar_countrymap = patchar_countrymap %>% left_join(patchar) %>% 
  select(-starts_with("ev_"),-starts_with("earliest"),-alpha,-cost,-pv,-ev,-docdb_family_size,-istrax_EUPLUSUK,-istrax_G7)

# Note: we have loads of innovations which are not mapped to countries...

#countrymap=patchar_countrymap %>% distinct(docdb_family_id,ctry_code)

#istraxes=patchar_countrymap %>% select(-ctry_code) %>% distinct()

#test2=test %>% select(docdb_family_id)


```



## Build techmap

```{r}
url="../patent analysis/Data/Other data/docdb_tech_class.csv"

techmap=fread(url)
techmap=techmap %>% arrange(docdb_family_id) %>% filter(technology!="")
#head(classes)
#classes %>% distinct(technology)

green_classes=c("Green Energy",
                "Green Transport",
                "Circular Economy",
                "Green Manufacturing",
                "Adaptation",
                "Green Housing",
                "Green ICT",
                "Green Agriculture",
                "GHG Capture",
                "Any Green")

#classes = classes %>% mutate(green_id=technology %in%  green_classes)

#classes %>% distinct(technology)



#url="../patent analysis/Data/Other data/docdb_green_or_not.csv"


# Add a mapping to green.... Sam, double check if you agree...

url="../../data/patent_data/Y02_docdb_family_id_patstat2021.dsv"
greenornot=fread(url) %>% mutate(technology="Any Green") %>% select(docdb_family_id, technology)
#head(greenornot)
techmap=techmap %>% bind_rows(greenornot) %>% distinct()


```


## Save stuff

```{r}

library(arrow)

# Save patchar_countrymap as patchar_countrymap.parquet
write_parquet(patchar_countrymap, "patchar_countrymap.parquet")

# Save techmap as techmap.parquet
write_parquet(techmap, "techmap.parquet")

write_parquet(patchar, "patchar.parquet")

#write_parquet(countrymap, "countrymap.parquet")
#write_parquet(istraxes, "istraxes.parquet")



# save istraxes in separate files so we can more easily upload to github
#names(istraxes)
# Create output directory if it doesn't exist
if (!dir.exists("istraxes")) {
  dir.create("istraxes")
}

# Identify istrax_* columns
istrax_cols <- grep("^istrax_", names(patchar_countrymap), value = TRUE)

# Loop through each istrax_* column and save with docdb_family_id and ctry_code
for (col in istrax_cols) {
  subset_df <- patchar_countrymap[, c("docdb_family_id","ctry_code", col)]
  write_parquet(subset_df, paste0("istraxes/", col, ".parquet"))
}



```


## copy stuff to ISEapp github repo as well


```{r}

if(Sys.info()["nodename"]=="PCACL-9RVSQ74" ){
  
  githubdir="C:/Users/rmartin7/GitHub/"  
  
}



# List of relative file paths
files1 <- list.files(path="istraxes", pattern = "parquet$", full.names = TRUE)
file_list <- c(files1,"techmap.parquet")



# Destination root directory
dest_root1 <- paste0(githubdir,"iseapp/")
dest_root2 <- paste0(githubdir,"KEVCE/data/")



# Create destination directories and copy files
for (file in file_list) {
  dest_path <- file.path(dest_root1, file)
  dest_dir <- dirname(dest_path)
  
  if (!dir.exists(dest_dir)) {
    dir.create(dest_dir, recursive = TRUE)
  }
  
  file.copy(from = file, to = dest_path, overwrite = TRUE)
  #########################################################
  
  
  dest_path <- file.path(dest_root2, file)
  dest_dir <- dirname(dest_path)
  
  if (!dir.exists(dest_dir)) {
    dir.create(dest_dir, recursive = TRUE)
  }
  
  file.copy(from = file, to = dest_path, overwrite = TRUE)


  
    
  
  
}

```




# Analysis
```{r}

source("istraxfunctions.r")

```

## Global vs National ISTRAX

Here we compare returns from further innovation at  global vs national spillovers. Note: going forward we want to add further scopes; e.g. LMIC istrax where only spillovers to LMICs are considered.




## Vietnam

toflowlabels:    Global Returns, National Returns, Returns within LMICs (excl. China), Returns within HICs
  
toflowcatnames:  istrax_global, istrax_nationalkey_2009_2018, istrax_EMDEexCN, istrax_HIC




```{r}





plot_avstrax_by_country(patchar_countrymap, 
                        techmap, 
                        green_classes, 
                        country_code="VN", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap,
                        techmap,
                        green_classes, 
                        country_code="VN", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")

plot_avstrax_by_country(patchar_countrymap,
                        techmap,
                        green_classes, 
                        country_code="VN", 
                        toflow="istrax_EMDEexCN", 
                        custom_colors)+ggtitle("Returns within LMICs (excl. China)")



```


## All dvelopping (ex China)


```{r}

lmics=c("AF","AL","DZ","AO","AR","AM","AZ","BD","BJ","BO","BA","BW","BR","BG","BF","BI","KH","CM","CV","CF","TD","CL","CO","KM","CG","CR","CI","CU","DJ","DM","DO","EC","EG","SV","GQ","ER","ET","FJ","GA","GM","GE","GH","GT","GN","GW","GY","HT","HN","IN","ID","IR","IQ","JM","JO","KZ","KE","KI","KP","KG","LA","LB","LS","LR","LY","MG","MW","MY","MV","ML","MR","MU","MX","MD","MN","ME","MA","MZ","MM","NA","NP","NI","NE","NG","MK","PK","PW","PA","PG","PY","PE","PH","RW","WS","ST","SN","RS","SC","SL","SB","SO","ZA","LK","SD","SR","SY","TJ","TZ","TH","TL","TG","TO","TN","TR","TM","TV","UG","UA","UZ","VU","VE","VN","YE","ZM","ZW")


plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code=lmics, 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                         green_classes, 
                        country_code=lmics, 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")
```


## China

```{r}



plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code="CN", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country( patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code="CN", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")




```


Africa only?

```{r}

lmics=c("TD","DZ","DJ","MZ","GM","GN","UG","GH","SN","ER",
        "CG","MA","TN","CM","MW","SD","NG","SO","EG","SL",
        "BF","BJ","ML","NE","MG","RW","CD","EH","CV","GW",
        "LR","ZA","SZ","ZM","KE","MR","TZ","LY","ZW","TG",
        "CF","ET","LS","GQ","KM","GA","CI","BI")


plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code=lmics, 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap, 
                         green_classes, 
                        country_code=lmics, 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")



```



# Turkey

```{r}

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code="TR", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap, green_classes, 
                        country_code="TR", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")



```




# India

```{r}

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes, 
                        country_code="IN", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap, green_classes, 
                        country_code="IN", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")



```

# South Africa

```{r}

test=patchar_countrymap %>% filter(ctry_code=="ZA")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,green_classes ,
                        country_code="ZA", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")


plot_avstrax_by_country(patchar_countrymap, 
                        techmap, green_classes, 
                        country_code="ZA", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")








```





# UK

```{r}

plot_avstrax_by_country(patchar_countrymap, 
                        techmap, 
                        green_classes, 
                        country_code="GB", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes ,
                        country_code="GB", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")



```



# Germany

```{r}

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes , 
                        country_code="DE", 
                        toflow="istrax_global", 
                        custom_colors)+ggtitle("Global Returns")

plot_avstrax_by_country(patchar_countrymap, 
                        techmap,
                        green_classes ,
                        country_code="DE", 
                        toflow="istrax_nationalkey_2009_2018", 
                        custom_colors)+ggtitle("National Returns")



```

