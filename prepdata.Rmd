# Prep data..



```{r}

library(dplyr)

```



```{r}
if (Sys.info()["nodename"] == "PCACL-9RVSQ7") {
  datad="C:\\Users\\rmartin7\\OneDrive - WBG\\projects\\PRINZGlobal\\imperial_college_visualization\\01_data"
  localbig="C:\\Users\\rmartin7\\OneDrive - Imperial College London\\inglobe"
}

```


# Load data

```{r}




url="../../data/patent_data/patbis2021/data/fromWATSON/innos_ctry_indicators.dsv"


#url="../../data/patent_data/patbis2021/data/fromWATSON/innos_istraxfield_nationalkey_2009_2018.dsv"

countrymap <- read_tsv(url)
cites=read_tsv(paste0(datad,"\\citenet_noself"))



```




## condensed address data...

```{r}

library(bigrquery)
library(DBI)

# Set your project ID
project_id <- "patbis"

# Option 1: Direct table download
# Specify dataset and table name
dataset <- "inglobe"
table <- "person_address_extract"

# Download the entire table
df <- bq_table_download(
  bq_table(project_id, dataset, table)
)


library(arrow)
write_parquet(df,paste0(localbig,"\\data\\person_address.parquet"))


```


## find locations...

we are using tidygeocoder & mapbox...

```{r}

library(tidygeocoder)

# create a dataframe with addresses


some_addresses <- tibble::tribble(
~name,                  ~addr,
"White House",          "1600 Pennsylvania Ave NW, Washington, DC",
"Transamerica Pyramid", "600 Montgomery St, San Francisco, CA 94111",     
"Willis Tower",         "233 S Wacker Dr, Chicago, IL 60606"                                  
)

some_addresses=df %>% head(1000)
# geocode the addresses
lat_longs_mapbox <- some_addresses %>%
  geocode(person_address, method = 'mapbox', lat = latitude , long = longitude)
#> Passing 3 addresses to the Nominatim single address geocoder
#> Query completed in: 3.2 seconds



recursive_mapbox=function(){
  df_filtered <- df %>%
    anti_join(lat_longs_mapbox, by = "person_id")
  
  df_filtered=df_filtered %>% mutate(rr=runif(1:n()))  %>% arrange(rr) %>% select(-rr)
  
  some_addresses=df_filtered %>% head(50000)
  print(nrow(df_filtered))
  lat_longs_mapbox2 <- some_addresses %>%
    geocode(person_address, method = 'mapbox', lat = latitude , long = longitude)
  
  
  lat_longs_mapbox_new=lat_longs_mapbox %>% bind_rows(lat_longs_mapbox2)
  return(lat_longs_mapbox_new)
}

#lat_longs_mapbox=lat_longs_mapbox_new  %>% distinct()
#lat_longs_mapbox=lat_longs_mapbox  %>% distinct() %>% select(-rr)


write_parquet(df,paste0(localbig,"\\data\\lat_longs_mapbox.parquet"))
lat_longs_mapbox=recursive_mapbox()



```


Cleaning up


```{r}

test=lat_longs_mapbox %>% filter(nchar(person_address)<=2)

testdf=lat_longs_mapbox %>% filter(!is.na(person_ctry_code) & !is.na(longitude))


library(sf)
library(rnaturalearth)

# Get world boundaries
world <- ne_countries(scale = "medium", returnclass = "sf")

# Convert dataframe to spatial points
df_sf <- st_as_sf(testdf, 
                  coords = c("longitude", "latitude"), 
                  crs = 4326)

# Initialize ok column
testdf$ok <- FALSE

# Check each point
for(i in 1:nrow(testdf)) {
  country_poly <- world[world$iso_a2 == testdf$person_ctry_code[i], ]
  if(nrow(country_poly) > 0) {
    testdf$ok[i] <- st_intersects(df_sf[i,], country_poly, sparse = FALSE)[1,1]
  }
}


```



Let's have a look:


```{r}

library(leaflet)

# With clustering (much better for 100k points!)
leaflet(lat_longs_mapbox) %>%
  addTiles() %>%
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    radius = 3,
    fillOpacity = 0.5,
    stroke = FALSE,
    clusterOptions = markerClusterOptions()
  )




```